#ifndef SKIFF_VM_HPP
#define SKIFF_VM_HPP

#include "libskiff/bytecode/executable.hpp"
#include "libskiff/machine/execution_context.hpp"
#include "libskiff/machine/memory.hpp"
#include "libskiff/types.hpp"

#include <array>
#include <memory>
#include <optional>
#include <stack>
#include <utility>
#include <vector>
#include "libskiff/types.hpp"

namespace libskiff {
namespace machine {

//! \brief Virtual machine
class vm_c : public executor_if {
public:
  static constexpr uint8_t num_integer_registers = 10;
  static constexpr uint8_t num_floating_point_registers = 10;

  //! \brief Result status of execution
  enum class execution_result_e {
    OKAY, //! Execution finished with no errors
    ERROR //! Execution finished due to an error
  };

  //! \brief Construct the VM
  vm_c();

  //! \brief Load the VM with an executable
  //! \returns True iff the VM can run the executable
  bool load(std::unique_ptr<libskiff::binary::executable_c> executable);

  //! \brief Set a callback to receive runtime errors
  //! \param cb The runtime callback
  //! \note There is only one callback stored. Calling this twice will
  //!       unset the first cb
  void set_runtime_callback(libskiff::types::runtime_error_cb cb);

  //! \brief Execute the loaded binary
  //! \returns Pair with execution status and
  //!          exit code generated by binary
  std::pair<execution_result_e, int> execute();

private:
  std::array<types::vm_integer_reg, num_integer_registers> _integer_registers{};
  std::array<types::vm_floating_point_reg, num_floating_point_registers>
      _floating_point_registers{};
  types::vm_integer_reg _x0{0};
  types::vm_integer_reg _x1{1};
  types::vm_integer_reg _ip{0};
  types::vm_integer_reg _fp{0};

  std::vector<std::unique_ptr<instruction_c>> _instructions;
  std::stack<uint64_t> _call_stack;

  std::optional<libskiff::types::runtime_error_cb> _runtime_error_cb;
  memory_c _memory;

  types::vm_integer_reg *get_int_reg(uint8_t id);
  types::vm_floating_point_reg *get_floating_point_reg(uint8_t id);

  virtual void accept(instruction_nop_c &ins) override;
  virtual void accept(instruction_exit_c &ins) override;
  virtual void accept(instruction_blt_c &ins) override;
  virtual void accept(instruction_bgt_c &ins) override;
  virtual void accept(instruction_beq_c &ins) override;
  virtual void accept(instruction_jmp_c &ins) override;
  virtual void accept(instruction_call_c &ins) override;
  virtual void accept(instruction_ret_c &ins) override;
  virtual void accept(instruction_mov_c &ins) override;
  virtual void accept(instruction_add_c &ins) override;
  virtual void accept(instruction_sub_c &ins) override;
  virtual void accept(instruction_div_c &ins) override;
  virtual void accept(instruction_mul_c &ins) override;
  virtual void accept(instruction_addf_c &ins) override;
  virtual void accept(instruction_subf_c &ins) override;
  virtual void accept(instruction_divf_c &ins) override;
  virtual void accept(instruction_mulf_c &ins) override;
  virtual void accept(instruction_lsh_c &ins) override;
  virtual void accept(instruction_rsh_c &ins) override;
  virtual void accept(instruction_and_c &ins) override;
  virtual void accept(instruction_or_c &ins) override;
  virtual void accept(instruction_xor_c &ins) override;
  virtual void accept(instruction_not_c &ins) override;
};

} // namespace machine
} // namespace libskiff

#endif