#ifndef SKIFF_VM_HPP
#define SKIFF_VM_HPP

#include "libskiff/bytecode/executable.hpp"
#include "libskiff/config.hpp"
#include "libskiff/machine/execution_context.hpp"
#include "libskiff/machine/memory/memman.hpp"
#include "libskiff/machine/memory/stack.hpp"
#include "libskiff/machine/system/callable.hpp"
#include "libskiff/types.hpp"

#include <array>
#include <memory>
#include <optional>
#include <stack>
#include <utility>
#include <vector>

namespace libskiff {
namespace machine {

//! \brief Virtual machine
class vm_c : public executor_if {
public:
  //! \brief Result status of execution
  enum class execution_result_e {
    OKAY, //! Execution finished with no errors
    ERROR //! Execution finished due to an error
  };

  //! \brief Construct the VM
  vm_c();

  //! \brief Destruct the VM
  ~vm_c();

  //! \brief Load the VM with an executable
  //! \returns True iff the VM can run the executable
  bool load(std::unique_ptr<libskiff::bytecode::executable_c> executable);

  //! \brief Set a callback to receive runtime errors
  //! \param cb The runtime callback
  //! \note There is only one callback stored. Calling this twice will
  //!       unset the first cb
  void set_runtime_callback(libskiff::types::runtime_error_cb cb);

  //! \brief Execute the loaded binary
  //! \returns Pair with execution status and
  //!          exit code generated by binary
  std::pair<execution_result_e, int> execute();

private:
  bool _is_alive{true};
  types::exec_debug_level_e _debug_level{types::exec_debug_level_e::NONE};
  std::array<types::vm_register, config::num_integer_registers>
      _integer_registers{};
  std::array<types::vm_register, config::num_floating_point_registers>
      _floating_point_registers{};
  types::vm_register _x0{0};
  types::vm_register _x1{1};
  types::vm_register _ip{0};
  types::vm_register _sp{0};
  types::vm_register _op_register{0};
  execution_result_e _return_value{execution_result_e::OKAY};

  std::vector<std::unique_ptr<instruction_c>> _instructions;
  std::stack<uint64_t> _call_stack;
  memory::stack_c _stack;
  memory::memman_c _memman;

  std::optional<libskiff::types::runtime_error_cb> _runtime_error_cb;
  std::vector<std::unique_ptr<system::callable_if>> _system_callables;

  types::vm_register *get_register(uint8_t id);
  void issue_forced_error(const std::string &err);
  void issue_forced_warning(const std::string &err);
  void kill_with_error(const types::runtime_error_e err,
                       const std::string &err_str);
  virtual void accept(instruction_nop_c &ins) override;
  virtual void accept(instruction_exit_c &ins) override;
  virtual void accept(instruction_blt_c &ins) override;
  virtual void accept(instruction_bgt_c &ins) override;
  virtual void accept(instruction_beq_c &ins) override;
  virtual void accept(instruction_jmp_c &ins) override;
  virtual void accept(instruction_call_c &ins) override;
  virtual void accept(instruction_ret_c &ins) override;
  virtual void accept(instruction_mov_c &ins) override;
  virtual void accept(instruction_add_c &ins) override;
  virtual void accept(instruction_sub_c &ins) override;
  virtual void accept(instruction_div_c &ins) override;
  virtual void accept(instruction_mul_c &ins) override;
  virtual void accept(instruction_addf_c &ins) override;
  virtual void accept(instruction_subf_c &ins) override;
  virtual void accept(instruction_divf_c &ins) override;
  virtual void accept(instruction_mulf_c &ins) override;
  virtual void accept(instruction_lsh_c &ins) override;
  virtual void accept(instruction_rsh_c &ins) override;
  virtual void accept(instruction_and_c &ins) override;
  virtual void accept(instruction_or_c &ins) override;
  virtual void accept(instruction_xor_c &ins) override;
  virtual void accept(instruction_not_c &ins) override;
  virtual void accept(instruction_bltf_c &ins) override;
  virtual void accept(instruction_bgtf_c &ins) override;
  virtual void accept(instruction_beqf_c &ins) override;
  virtual void accept(instruction_asne_c &ins) override;
  virtual void accept(instruction_aseq_c &ins) override;
  virtual void accept(instruction_push_w_c &ins) override;
  virtual void accept(instruction_push_dw_c &ins) override;
  virtual void accept(instruction_push_qw_c &ins) override;
  virtual void accept(instruction_pop_w_c &ins) override;
  virtual void accept(instruction_pop_dw_c &ins) override;
  virtual void accept(instruction_pop_qw_c &ins) override;
  virtual void accept(instruction_alloc_c &ins) override;
  virtual void accept(instruction_free_c &ins) override;
  virtual void accept(instruction_store_word_c &ins) override;
  virtual void accept(instruction_store_dword_c &ins) override;
  virtual void accept(instruction_store_qword_c &ins) override;
  virtual void accept(instruction_load_word_c &ins) override;
  virtual void accept(instruction_load_dword_c &ins) override;
  virtual void accept(instruction_load_qword_c &ins) override;
  virtual void accept(instruction_syscall_c &ins) override;
  virtual void accept(instruction_debug_c &ins) override;
};

} // namespace machine
} // namespace libskiff

#endif