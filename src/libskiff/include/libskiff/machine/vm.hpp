#ifndef SKIFF_VM_HPP
#define SKIFF_VM_HPP

#include "libskiff/types.hpp"
#include "libskiff/bytecode/executable.hpp"
#include "libskiff/machine/execution_context.hpp"
#include "libskiff/machine/memory.hpp"

#include <array>
#include <memory>
#include <optional>
#include <utility>
#include <vector>
#include <stack>

namespace libskiff
{
namespace machine
{

//! \brief Virtual machine
class vm_c
{
public:
  static constexpr uint8_t num_integer_registers = 10;
  static constexpr uint8_t num_floating_point_registers = 10;

  //! \brief Result status of execution
  enum class execution_result_e {
    OKAY,   //! Execution finished with no errors
    ERROR   //! Execution finished due to an error
  };

  //! \brief Construct the VM with a loaded executable
  vm_c(std::unique_ptr<libskiff::binary::executable_c> executable);

  //! \brief Set a callback to receive runtime errors
  //! \param cb The runtime callback
  //! \note There is only one callback stored. Calling this twice will
  //!       unset the first cb
  void set_runtime_callback(libskiff::types::runtime_error_cb cb);

  //! \brief Execute the loaded binary
  //! \returns Pair with execution status and 
  //!          exit code generated by binary
  std::pair<execution_result_e, int> execute();

private:
  struct registers_t {
    std::array<types::vm_integer_reg, num_integer_registers> _integer_registers;
    std::array<types::vm_floating_point_reg, num_floating_point_registers> _floating_point_registers;
    types::vm_integer_reg x0;
    types::vm_integer_reg x1;
    types::vm_integer_reg ip;
    types::vm_integer_reg fp;
  };

  std::vector<std::unique_ptr<instruction_c>> _instructions;
  std::stack<uint64_t> _call_stack;
  register_t _registers;


  std::optional<libskiff::types::runtime_error_cb> _runtime_error_cb;
  memory_c _memory;
};

}
}


#endif